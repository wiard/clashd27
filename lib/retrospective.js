/**
 * CLASHD-27 — Retrospective Validation Module
 * Checks whether hypotheses generated by the pipeline were later
 * confirmed or refuted by published literature.
 *
 * NOT called automatically — manual CLI use only.
 *
 * Usage: node -e "require('./lib/retrospective').retrospectiveCheck('find-0024')"
 */

const fs = require('fs');
const path = require('path');

const API_URL = 'http://localhost:3027/api/weigh';
const MODEL = 'claude-sonnet-4-20250514';
const RETRO_FILE = path.join(__dirname, '..', 'data', 'retrospective.json');
const FINDINGS_FILE = path.join(__dirname, '..', 'data', 'findings.json');

function readRetro() {
  try {
    if (fs.existsSync(RETRO_FILE)) {
      return JSON.parse(fs.readFileSync(RETRO_FILE, 'utf8'));
    }
  } catch (e) {
    console.error('[RETRO] Read failed:', e.message);
  }
  return { outcomes: [] };
}

function saveRetro(data) {
  const dir = path.dirname(RETRO_FILE);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
  fs.writeFileSync(RETRO_FILE, JSON.stringify(data, null, 2));
}

function readFindings() {
  try {
    if (fs.existsSync(FINDINGS_FILE)) {
      return JSON.parse(fs.readFileSync(FINDINGS_FILE, 'utf8'));
    }
  } catch (e) {}
  return { findings: [] };
}

function stripCitations(text) {
  if (!text) return text;
  return text.replace(/<cite[^>]*>/g, '').replace(/<\/cite>/g, '');
}

function parseJSON(text) {
  if (!text) return null;
  text = stripCitations(text);
  try { return JSON.parse(text); } catch (e) { /* fall through */ }
  try {
    const m = text.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
    if (m) return JSON.parse(m[1]);
  } catch (e) { /* fall through */ }
  try {
    const start = text.indexOf('{');
    if (start !== -1) {
      let depth = 0, end = -1;
      for (let i = start; i < text.length; i++) {
        if (text[i] === '{') depth++;
        else if (text[i] === '}') { depth--; if (depth === 0) { end = i; break; } }
      }
      if (end !== -1) return JSON.parse(text.substring(start, end + 1));
    }
  } catch (e) {}
  return null;
}

/**
 * Record a manual retrospective outcome
 */
function addOutcome(discoveryId, outcome, source, notes) {
  const data = readRetro();
  data.outcomes.push({
    discovery_id: discoveryId,
    outcome,
    source,
    notes,
    timestamp: new Date().toISOString()
  });
  saveRetro(data);
  console.log(`[RETRO] ${discoveryId} → ${outcome} (${source})`);
  return data.outcomes[data.outcomes.length - 1];
}

function getOutcomes(discoveryId) {
  const data = readRetro();
  if (discoveryId) return data.outcomes.filter(o => o.discovery_id === discoveryId);
  return data.outcomes;
}

function getSummary() {
  const outcomes = readRetro().outcomes;
  const total = outcomes.length;
  const confirmed = outcomes.filter(o => o.outcome === 'confirmed').length;
  const refuted = outcomes.filter(o => o.outcome === 'refuted').length;
  const partial = outcomes.filter(o => o.outcome === 'partially_confirmed').length;
  const hitRate = total > 0 ? Math.round((confirmed / total) * 100) : 0;
  return { total, confirmed, refuted, partial, hitRate };
}

/**
 * Retrospective check: search for papers published AFTER discovery date
 * that confirm, contradict, or investigate the hypothesis.
 *
 * Usage: node -e "require('./lib/retrospective').retrospectiveCheck('find-0024')"
 */
async function retrospectiveCheck(discoveryId) {
  // Load discovery
  const findingsData = readFindings();
  const discovery = (findingsData.findings || []).find(f => f.id === discoveryId);
  if (!discovery) {
    console.error(`[RETRO] Discovery ${discoveryId} not found`);
    return null;
  }

  const hypothesis = discovery.hypothesis || discovery.discovery || '';
  const discoveryDate = discovery.timestamp || '';
  const domains = (discovery.cellLabels || []).join(' × ');

  console.log(`[RETRO] Checking ${discoveryId}: "${hypothesis.substring(0, 80)}..."`);
  console.log(`[RETRO] Discovery date: ${discoveryDate}`);

  const systemPrompt = 'You are a biomedical literature analyst. Search for papers published AFTER the given date that are relevant to the hypothesis. Determine if the hypothesis was confirmed, refuted, partially confirmed, or remains untested.';

  const userPrompt = `Hypothesis: ${hypothesis}
Domains: ${domains}
Discovery date: ${discoveryDate}

Search for papers published AFTER ${discoveryDate.slice(0, 10) || '2025-01-01'} that:
1. Directly test this hypothesis or a very similar one
2. Provide new evidence supporting or contradicting the proposed mechanism
3. Report clinical results relevant to this connection

Return ONLY valid JSON:
{
  "outcome": "confirmed|refuted|partially_confirmed|untested",
  "supporting_papers": [
    {"title": "...", "authors": "...", "journal": "...", "year": "...", "relevance": "direct|indirect"}
  ],
  "contradicting_papers": [
    {"title": "...", "authors": "...", "journal": "...", "year": "...", "finding": "what contradicts"}
  ],
  "summary": "2-3 sentences explaining the current status of this hypothesis",
  "confidence": 0-100
}`;

  try {
    const response = await fetch(API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: MODEL,
        max_tokens: 2000,
        system: systemPrompt,
        tools: [{ type: 'web_search_20250305', name: 'web_search' }],
        messages: [{ role: 'user', content: userPrompt }]
      })
    });

    if (!response.ok) {
      console.error(`[RETRO] API error: ${response.status}`);
      return null;
    }

    const data = await response.json();
    if (data.error) {
      console.error(`[RETRO] API error: ${data.error.message}`);
      return null;
    }

    let text = '';
    if (data.content) {
      for (const block of data.content) {
        if (block.type === 'text') text += block.text;
      }
    }

    const parsed = parseJSON(text);
    if (!parsed) {
      console.error('[RETRO] Failed to parse response');
      return null;
    }

    // Save result
    const retroData = readRetro();
    const entry = {
      discovery_id: discoveryId,
      hypothesis,
      outcome: parsed.outcome || 'untested',
      supporting_papers: parsed.supporting_papers || [],
      contradicting_papers: parsed.contradicting_papers || [],
      summary: stripCitations(parsed.summary || ''),
      confidence: parsed.confidence || 0,
      checked_at: new Date().toISOString()
    };
    retroData.outcomes.push(entry);
    saveRetro(retroData);

    console.log(`[RETRO] ${discoveryId} → ${entry.outcome} (confidence: ${entry.confidence}%)`);
    console.log(`[RETRO] ${entry.summary}`);
    return entry;
  } catch (err) {
    console.error(`[RETRO] Check failed: ${err.message}`);
    return null;
  }
}

module.exports = {
  addOutcome,
  getOutcomes,
  getSummary,
  readRetro,
  retrospectiveCheck
};
